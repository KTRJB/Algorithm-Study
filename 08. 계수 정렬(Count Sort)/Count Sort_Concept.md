# 📚 계수 정렬(Counting Sort)

## 🐻 개념
>`데이터들의 크기에 따라 정렬`해주는 정렬 알고리즘으로,
기존 선택 정렬, 삽입 정렬 등에 비해 시간복잡도가 빠른 정렬 알고리즘이다.

지금까지의 정렬은 크기에 따라 데이터의 위치를 바꿔가며 정렬을 했다면, 계수 정렬은 위치를 굳이 바꾸지 않고 단순히 크기에만 기준을 맞춰 갯수를 세준다. 또한 데이터에 각 한번씩만 접근하면 되기 때문에 다른 정렬보다 효율적이다.



### 제약 사항

1. `데이터(값)은 양수`여야 한다.
2. 값의 범위가 너무 크지 않아야 한다.(메모리 사이즈를 넘어서는 안된다.)

## 🐻 계수 정렬 과정
카운팅(계수) 정렬 수행 과정은 다음의 단계로 이루어진다.

1. 가장 작은 데이터부터 가장 큰 데이터까지의 범위가 모두 담길 수 있는 리스트를 생성
2. 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가
3. 증가된 리스트에서 0인 값을 제외하고, 인덱스를 인덱스 값만큼 출력

![](https://i.imgur.com/0JKWY0B.gif)


## 🐻 시간 복잡도

1. 만약 최대값이 주어지지 않은 경우 전체 배열을 탐색해야 함 ➡️ **O(n)** 이 소요
2. Counting Array에 개수를 count하는 과정 ➡️ **O(n)** 이 소요
3.  이후 출력 배열에 값을 입력하여 정렬된 배열을 얻는 과정  ➡️ **O(n)** 이 소요

따라서 시간 복잡도는 **O(n)** 이 된다.

❗️ `배열의 길이가 작은데 배열의 최댓값 K는 굉장히 클 경우`**(ex. [1, 10000])** ➡️ **O(n+k)** 이 소요

### 🐻 예시 
> 만약 k가 n보다 작은 수이면 O(n)이 되지만, k가 n보다 매우 큰 수이면 O(무한)이 될 수도 있다. 예를 들어 10개의 숫자를 정렬하는 데, 가장 큰 숫자가 100일 경우, O(n^2)이 된다. 100(k)은 10(n)의 제곱이기 때문이다. 1000이면 O(n^3)이 된다. 즉 정렬할 수들의 최대값에 영향을 받는 알고리즘이라고 볼 수 있다.
 
결론은 `K가 최대한 작아야 유리`하므로 입력값의 범위가 작을 때 높은 효율을 보인다.

