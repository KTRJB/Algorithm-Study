## 수꿍
- 구현
```swift
let graphs: [String: [String: Int]] = [
    "A": ["B": 5, "C": 1],
    "B": ["D": 15, "E": 20],
    "C": ["D": 30, "E": 35],
    "D": ["F": 20],
    "E": ["F": 10],
    "F": [:]
]

var distances = [
    "B": 5,
    "C": 1,
    "D": Int.max,
    "E": Int.max,
    "F": Int.max
]

var previousNodes = [
    "B": "A",
    "C": "A",
    "D": "",
    "E": "",
    "F": ""
]

var visitedNodes: [String] = []

func findProximateNode(distances: [String: Int]) -> String {
    var shortestDistance = Int.max
    var previousNode = ""

    for (key, value) in distances {
        if value < shortestDistance && !visitedNodes.contains(key){
            shortestDistance = value
            previousNode = key
        }
    }

    return previousNode
}

func makeShortestRoute(endpoint: String) -> [String] {
    var routes: [String] = []
    routes.append(endpoint)

    var previousNode = previousNodes[endpoint]
    routes.append(previousNode!)

    while previousNode != "A" {
        previousNode = previousNodes[previousNode!]
        routes.append(previousNode!)
    }

    return routes.reversed()
}

func dijkstra(endpoint: String) {
    var node = findProximateNode(distances: distances)

    while node != "" {
        let distance = distances[node]
        let neighbors = graphs[node]

        for (key, value) in neighbors! {
            let newDistance = distance! + value

            if newDistance < distances[key]! {
                distances[key] = newDistance
                previousNodes[key] = node
            }
        }

        visitedNodes.append(node)
        node = findProximateNode(distances: distances)
    }

    let routes = makeShortestRoute(endpoint: endpoint)

    print("최단경로는 \(routes) 거리는 \(distances[endpoint]!)")
}

dijkstra(endpoint: "F")
```

- 설명
```swift
// 노드, 간선을 다루는 그래프 생성
let graphs: [String: [String: Int]] = [
    "A": ["B": 5, "C": 1],
    "B": ["D": 15, "E": 20],
    "C": ["D": 30, "E": 35],
    "D": ["F": 20],
    "E": ["F": 10],
    "F": [:]
]

// startNode에서 다른 Node간 거리 표시
// 모든 간선은 먼저 Int.max로 표시
// 값이 있는 간선은 해당 간선 대입
var distances = [
    "B": 5,
    "C": 1,
    "D": Int.max,
    "E": Int.max,
    "F": Int.max
]

// 최적 경로 산출을 위한 이전 노드값 저장
var previousNodes = [
    "B": "A",
    "C": "A",
    "D": "",
    "E": "",
    "F": ""
]

// 동적 계획법을 적용하여
// 이전에 방문한 노드는 재방문하지 않기 위한
// 방문 노드 배열 생성
var visitedNodes: [String] = []

// 가장 가까운 노드를 찾기 위한 함수 생성
func findProximateNode(distances: [String: Int]) -> String {
    var shortestDistance = Int.max
    var previousNode = ""

    for (key, value) in distances {
        // 현재 거리가 최단 거리보다 짧으면서, 방문한 노드가 아닌 경우
        // 최단 거리와 이전 노드 최신화를 위한 조건문 생성
        if value < shortestDistance && !visitedNodes.contains(key){
            shortestDistance = value
            previousNode = key
        }
    }

    return previousNode
}

// 최단 경로 배열 반환 함수 생성
func makeShortestRoute(endpoint: String) -> [String] {
    var routes: [String] = []
    // 종점을 배열에 우선 추가
    routes.append(endpoint)

    // 종점의 이전 노드 배열 내 추가
    var previousNode = previousNodes[endpoint]
    routes.append(previousNode!)

    // 시작점에 이르기까지 이전 노드 배열 내 추가
    while previousNode != "A" {
        previousNode = previousNodes[previousNode!]
        routes.append(previousNode!)
    }

    // 배열을 역전시켜 시작좀부터 종점에 이르기까지 경로 반환
    return routes.reversed()
}

// 다익스트라 함수 생성
func dijkstra(endpoint: String) {
    // 우선적으로 최단 거리의 노드를 저장
    var node = findProximateNode(distances: distances)

    // node가 ""인 경우는 findProximateNode 함수에
    // 이후의 노드를 가지 못한 경우
    // 즉, 종점에 이르렀음을 의미하므로 조건문을 종료
    while node != "" {
        // 현재 저장된 거리 배열에서 해당 노드까지의 거리를 가져옴
        let distance = distances[node]
        // 현재 노드의 인접 노드 딕셔너리 호출
        let neighbors = graphs[node]

        // 인접 노드 딕셔너리 내에 반복문 호출
        for (key, value) in neighbors! {
            // 현재 새롭게 도출한 거리를 담는 상수 생성
            let newDistance = distance! + value

            // 이전 거리와 비교하여 현재의 거리가 더 짧은 경우 최신화
            if newDistance < distances[key]! {
                distances[key] = newDistance
                previousNodes[key] = node
            }
        }

        // 방문 노드임을 표시
        visitedNodes.append(node)

        // 다음으로 최소 거리를 가진 노드 탐색
        node = findProximateNode(distances: distances)
    }

    // 최단 경로 호출
    let routes = makeShortestRoute(endpoint: endpoint)

    // 결과 print
    print("최단경로는 \(routes) 거리는 \(distances[endpoint]!)")
}

// 다익스트라 함수를 호출하여 종점까지의 최단 경로 및 거리 확인
dijkstra(endpoint: "F")
```

## Judy
```swift
let A = Node("A")
let B = Node("B")
let C = Node("C")
let D = Node("D")
let E = Node("E")
let F = Node("F")


let dijkstraGraph: [Node: [Node: Int]] = [
    A : [B: 9, C : 1, D : 15],
    B : [E: 10],
    C : [B: 5, E : 3],
    D : [E: 10],
    E : [F: 7],
    F : [:]
]

var paths = [Node: [Node]]()

func dijkstra(start: Node) -> [Node: Int] {
    var distances = [Node: Int]()
    let priorityQueue = Queue<NodePriority>()
    
    priorityQueue.enqueue(NodePriority(node: start, priority: 0))
    
    for node in dijkstraGraph.keys {
        node == start ? (distances[node] = 0) : (distances[node] = Int.max)
    }
    
    while priorityQueue.isEmpty == false {
        guard let visitNode = priorityQueue.dequeue() else { break }
        
        if distances[visitNode.node]! < visitNode.priority {
            continue
        }
        
        for (node, priority) in dijkstraGraph[visitNode.node]! {
            let distance = priority + visitNode.priority
            
            if distance < distances[node]! {
                distances[node] = distance
                priorityQueue.enqueue(NodePriority(node: node, priority: distance))
            }
        }
    }
    
    return distances
}



struct NodePriority: Comparable {
    var node: Node
    var priority: Int = 0
    
    static func < (lhs: NodePriority, rhs: NodePriority) -> Bool {
        lhs.priority > rhs.priority
    }
    
    static func == (lhs: NodePriority, rhs: NodePriority) -> Bool {
        lhs.priority == rhs.priority
    }
}

struct Node: Hashable {
    let value: String
    
    init(_ value: String) {
        self.value = value
    }
    
    static func == (lhs: Node, rhs: Node) -> Bool {
        return lhs.value == rhs.value
    }
}
```
