### ìˆ˜ê¿
- DFS êµ¬í˜„
```swift
let graph: [String: [String]] = [
    "A" : ["B", "C"],
    "B" : ["A", "D", "E"],
    "C" : ["A", "F"],
    "D" : ["B"],
    "E" : ["B"],
    "F" : ["C"],
]

func DFS(graph: [String: [String]], start: String) -> [String] {
    var visitedQueue: [String] = []
    var needVisitStack: [String] = [start]

    while !needVisitStack.isEmpty {
        let node: String = needVisitStack.removeLast()

        if !visitedQueue.contains(node) {
            visitedQueue.append(node)
            needVisitStack += graph[node] ?? []
        }
    }

    return visitedQueue
}

print(DFS(graph: graph, start: "A"))
```
- DFS ì„¤ëª…
```swift
// íƒìƒ‰í•  ê·¸ë˜í”„ ìƒì„±
let graph: [String: [String]] = [
    // key ê°’ì€ ì‹œì‘ ë…¸ë“œ
    // value ë°°ì—´ ë‚´ ê°ê°ì˜ ê°’ì€ ì´ë™ ê°€ëŠ¥ ë…¸ë“œ
    "A" : ["B", "C"],
    "B" : ["A", "D", "E"],
    "C" : ["A", "F"],
    "D" : ["B"],
    "E" : ["B"],
    "F" : ["C"],
]

func DFS(graph: [String: [String]], start: String) -> [String] {
    // ì´ë¯¸ íƒìƒ‰í•œ ë…¸ë“œë¥¼ ë‹´ê¸° ìœ„í•œ í
    var visitedQueue: [String] = []
    // í•´ë‹¹ ë…¸ë“œì— ì ‘ê·¼í•˜ì—¬ ë‹¤ìŒìœ¼ë¡œ ì ‘ê·¼í•  ë…¸ë“œë¥¼ ë‹´ê¸° ìœ„í•œ "ìŠ¤íƒ"
    var needVisitStack: [String] = [start]

    // ì ‘ê·¼í•˜ê³ ì í•  ë…¸ë“œê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ë•Œê¹Œì§€ ë°˜ë³µ
    while !needVisitStack.isEmpty {
        // Stackì€ LIFO ë°©ì‹ì´ê¸° ë•Œë¬¸ì—, í•´ë‹¹ ë°°ì—´ì—ì„œ removeLast
        let node: String = needVisitStack.removeLast()

        // ì´ë¯¸ ë°©ë¬¸í•œ ë…¸ë“œê°€ ì•„ë‹Œ, ì²˜ìŒ ë°©ë¬¸í•œ ë…¸ë“œë¼ë©´
        // visitedQueueì— ë“±ë¡í•˜ê³ 
        // ë°©ë¬¸í•´ì•¼í•  ë…¸ë“œë¥¼ needVisitStackì— ë“±ë¡
        // í•´ë‹¹ ì¡°ê±´ë¬¸ ì—†ì„ì‹œ ë¬´í•œë£¨í”„ì˜ ìœ„í—˜ì— ë¹ ì§
        if !visitedQueue.contains(node) {
            visitedQueue.append(node)
            needVisitStack += graph[node] ?? []
        }
    }

    // ê¹Šì´ ìš°ì„  íƒìƒ‰í•œ íë¥¼ ë°˜í™˜
    return visitedQueue
}

// DFSê°€ ì •ìƒì ìœ¼ë¡œ ì‘ë™í•˜ì˜€ëŠ”ì§€ í™•ì¸
print(DFS(graph: graph, start: "A"))
```
- BFS êµ¬í˜„
```swift
let graph: [String: [String]] = [
    "A" : ["B", "C"],
    "B" : ["A", "D", "E"],
    "C" : ["A", "F"],
    "D" : ["B"],
    "E" : ["B"],
    "F" : ["C"],
]

func BFS(graph: [String: [String]], start: String) -> [String] {
    var visitedQueue: [String] = []
    var needVisitQueue: [String] = [start]

    while !needVisitQueue.isEmpty {
        let node: String = needVisitQueue.removeFirst()

        if !visitedQueue.contains(node) {
            visitedQueue.append(node)
            needVisitQueue += graph[node] ?? []
        }
    }

    return visitedQueue
}

print(BFS(graph: graph, start: "A"))

```
- BFS ì„¤ëª…
```swift
// íƒìƒ‰í•  ê·¸ë˜í”„ ìƒì„±
let graph: [String: [String]] = [
    // key ê°’ì€ ì‹œì‘ ë…¸ë“œ
    // value ë°°ì—´ ë‚´ ê°ê°ì˜ ê°’ì€ ì´ë™ ê°€ëŠ¥ ë…¸ë“œ
    "A" : ["B", "C"],
    "B" : ["A", "D", "E"],
    "C" : ["A", "F"],
    "D" : ["B"],
    "E" : ["B"],
    "F" : ["C"],
]

func BFS(graph: [String: [String]], start: String) -> [String] {
    // ì´ë¯¸ íƒìƒ‰í•œ ë…¸ë“œë¥¼ ë‹´ê¸° ìœ„í•œ í
    var visitedQueue: [String] = []
    // í•´ë‹¹ ë…¸ë“œì— ì ‘ê·¼í•˜ì—¬ ë‹¤ìŒìœ¼ë¡œ ì ‘ê·¼í•  ë…¸ë“œë¥¼ ë‹´ê¸° ìœ„í•œ "í"
    var needVisitQueue: [String] = [start]

    // ì ‘ê·¼í•˜ê³ ì í•  ë…¸ë“œê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ë•Œê¹Œì§€ ë°˜ë³µ
    while !needVisitQueue.isEmpty {
        // QueueëŠ” FIFO ë°©ì‹ì´ê¸° ë•Œë¬¸ì—, í•´ë‹¹ ë°°ì—´ì—ì„œ removeFirst
        let node: String = needVisitQueue.removeFirst()

        // ì´ë¯¸ ë°©ë¬¸í•œ ë…¸ë“œê°€ ì•„ë‹Œ, ì²˜ìŒ ë°©ë¬¸í•œ ë…¸ë“œë¼ë©´
        // visitedQueueì— ë“±ë¡í•˜ê³ 
        // ë°©ë¬¸í•´ì•¼í•  ë…¸ë“œë¥¼ needVisitQueueì— ë“±ë¡
        // í•´ë‹¹ ì¡°ê±´ë¬¸ ì—†ì„ì‹œ ë¬´í•œë£¨í”„ì˜ ìœ„í—˜ì— ë¹ ì§
        if !visitedQueue.contains(node) {
            visitedQueue.append(node)
            needVisitQueue += graph[node] ?? []
        }
    }

    // ë„ˆë¹„ ìš°ì„  íƒìƒ‰í•œ íë¥¼ ë°˜í™˜
    return visitedQueue
}

// BFSê°€ ì •ìƒì ìœ¼ë¡œ ì‘ë™í•˜ì˜€ëŠ”ì§€ í™•ì¸
print(BFS(graph: graph, start: "A"))

```

### ì˜ˆí†¤

```swift
let graph = [
    [], // 0
    [2,3], // 1
    [1,4,5], // 2
    [1,6,7], // 3
    [2], // 4
    [2], // 5
    [3], // 6
    [3,8], // 7
    [7] // 8
]

var visited = Array.init(repeating: false, count: graph.count)

// ğŸ£ dfs

func dfs(start: Int) {
  visited[start] = true // ì‹œì‘ì 
  
  print(start, terminator: " ")
  
  for i in graph[start] { // ì™¼ìª½ë¶€í„° ìˆœíšŒ
    if !visited[i] {
      dfs(start: i)
    }
  }
}

dfs(start: 1)

// ì¶œë ¥ê²°ê³¼
// 1 2 4 5 3 6 7 8

// ğŸ£ bfs 

var queue = Queue<Int>()

func bfs(start: Int) {
  queue.enquque(start) // ì‹œì‘ì  íì— ë„£ê¸°
  visited[start] = true // ì‹œì‘ì  ë°©ë¬¸ìœ¼ë¡œ ì²´í¬
  
  while !queue.isEmpty {
    guard let elem = queue.dequeue() else { return }
    print(elem, terminator: " ")
    
    for i in graph[elem] {
      if !visited[i] {
        queue.enquque(i)
        visited[i] = true
      }
    }
  }
}

// ì¶œë ¥ê²°ê³¼
// 1 2 3 4 5 6 7 8
```

### Judy
<img width="490" alt="image" src="https://user-images.githubusercontent.com/102353787/211225550-34ce35b3-eacc-42d7-b17f-0aa1711088fc.png">


```swift
let graph = [[1, 2],
             [0, 3, 4],
             [0],
             [1, 5, 6],
             [1],
             [3],
             [3]
]

var isVisited = Array(repeating: false, count: graph.count)

// DFS
func depthFirstSearch(start: Int) -> [Int] {
    var searchList: [Int] = []
    var needVisitStack = [start]
    
    while !needVisitStack.isEmpty  {
        let node = needVisitStack.removeLast()
        if isVisited[node] { continue }
        
        isVisited[node] = true
        searchList.append(node)
        graph[node].forEach {
            needVisitStack.append($0)
        }
    }
    
    return searchList
}

depthFirstSearch(start: 0)

// BFS
func breadthFirstSearch(start: Int) -> [Int] {
    var serchList: [Int] = [start]
    let queue = Queue<Int>()
    queue.enqueue(start)
    
    while !queue.isEmpty {
        guard let node = queue.dequeue() else { return [] }
        isVisited[node] = true
        
        graph[node].forEach {
            if isVisited[$0] != true {
                queue.enqueue($0)
                serchList.append($0)
                isVisited[$0] = true
            }
        }
    }
    
    return serchList
}

breadthFirstSearch(start: 0)
```
